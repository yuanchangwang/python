day07基础数据类型补充

## 今日内容概要

1. 基础数据类型
2. 循环删除的坑
3. 二次编码

## 内容回顾

1. 驻留机制
   - 小数据池
     - 数字：-5 ~ 256
     - 字符串：定义和乘法操作时均不能有中文或字符
       - python3.6版本乘法操作结果最大长度20
       - python3.7版本乘法操作结果最大长度4096
     - 布尔值
   - 代码块
     - 数字：-5~正无穷
     - 字符串：乘法操作时均不能有中文或字符，定义时可以有
       - 乘法操作结果最大长度为20
     - 布尔值
     - 代码块的优先级高于小数据池
     - 代码块：一个py文件，一个模块，一个类。一个函数，交互模式下的每一行代码
2. 深浅拷贝
   - 赋值：多个变量名指向同一个内存地址
   - 浅拷贝：只拷贝最外层元素的内存地址
   - 深拷贝：不可变数据共用，可变元素新开辟内存空间
   - ==：用于判断两边的值是否相等
   - is：用来判断两边的内存地址是否相同
3. 集合
   - set，天然去重
   - 集合是一个没有值的字典
   - 集合增加：add，update
   - 集合删除：pop，remove，clear
   - 集合的修改：先删后加，改为其他数据类型
   - 集合的查看：for循环
   - 集合关系：
     - 交集：&
     - 并集：|
     - 差集 -
     - 补集（反差集，对称差集）：^
     - 父集：>
     - 子集：<

## 今日内容详细

### 基础数据类型补充

#### 整型

`.bit_length`方法用来计算整型数字转换为二进制所占我位数：

```python
a = 10
print(a.bit_length())

结果：
4
```

这个方法的意思是，10转换为2进制数时1010，一共会占用4为。

#### 字符串

`.capitalize()`方法用来将字符串的首字母大写：

```python
s = "yuan chang"
s1 = s.capitalize()
print(s1)

结果
Yuan chang
```

`.title()` 方法能将字符串每个单词首字母大写，区分首字母的方式有空格，符号，和数字等：

```python
s = "yuan chang-meEt4san"
s1 = s.title()
print(s1)

结果：
Yuan Chang-Meet4San
```

`index()`方法用来通过元素查找索引，查找不到时会报错：

```python
s = "yaun chang"
print(s.index("a"))
```

`.find()`方法同样用来通过元素查找索引，与`.index()`方法不同的是，`.find()`方法找不到时会返回-1，而不会报错：

```python
s = "yuan chang"
print(s.find("l"))
```

`.center()`方法用来进行居中操作，会在字符串两端插入等量的空格，使得字符串总长度等于输入的参数：

```python
s = "yuan chang"
print(s.center(20))
```

也可以指定两端填充的内容：

```python
print(s.senter("20", "*"))
```

`.format()`方法是另外一种字符串格式的方法：

```python
s = "yuan{}chang{}si{}r"
s1 = s.format("你好"，"我好"，"大家好")
print(s1)
```

`.format()`方法除了上面这种按照位置格式化之外，还可以按照索引格式化：

```python
s = "yuan{2}chang{1}si{0}r"
s1 = s.format("你好"，"我好"，"大家好")
print(s1)
```

`.format()`方法还可以按照关键字进行格式化：

```python
s = "yuan{a}chang{c}si{b}r"
s1 = s.format(a="你好"，b="我好"，c="大家好")
print(s1)
```

`.swapcase()`方法可以反转字符串中字母的大小写：

```python
s = "Yuan chanG"
s1 = s.swapcase()
print(s1)
```

这里插入一个PyCharm的使用技巧：`ctrl + shift + r`打开替换窗口。



#### 列表

对列表进行反转操作，我们可以通过切片的方式进行：

```python
lst = [1, 2, 3, 4, 5, 6]
print(lst[::-1])
```

这种方法没有对原来的列表进行修改，而是创建了一个新列表。如果我们想对原来的列表进行改动，可以将切片后的结果赋值给lst。也可以使用`.reverse()`的方法，对列表本身进行原地的反转操作：

```python
lst = [1, 2, 3, 4, 5, 6]
lst.reverse()
print(lst)
```

列表的`.sort()`方法可以将混乱的列表排序，默认是按照升序排序：

```python
lst = [2, 1, 3, 4 ,6, 5]
lst.sort()
print(lst)

结果：[1, 2, 3, 4, 5, 6]
```



我们可以混合使用reverse方法将升序的列表反转，达到降序的目的。也可以通过将`.sort()`方法中的参数reverse设置为True，来让列表进行降序排序：

```
lst = [2, 1, 3, 4, 6, 5]
lst.sort(reverse=True)
print(lst)

输出的结果为：[6, 5, 4, 3, 2, 1]
```

`.index()`方法通过元素名来查找该元素在列表中的索引：

```
lst = [1,2,3,4,6,5]
print(lst.index(4))

输出的结果为：3
```

需要注意的是，如果需要查询的元素在列表中不止一个，`.index()`方法只会返回从左面数第一个元素的索引值：

```
lst = [1,2,3,4,4,6,5]
print(lst.index(4))

输出的结果仍然是：3
```

跟字符串类似，列表也可以进行加法和乘法的操作：

```
lst1 = [1, 2, 3, [4]]
lst2 = [4, 5, 6]
print(lst1 + lst2)
print(lst2 * 3)

输出的结果为：
[1, 2, 3, [4], 4, 5, 6]
[4, 5, 6, 4, 5, 6, 4, 5, 6]
```

需要注意的是，列表的加法和乘法都是新开一个空间存储结果，而不是对原列表进行操作。但是加法和乘法的结果所使用的元素仍然是原列表中的。相应的操作与浅拷贝就很类似了：

```
lst1 = [1, 2, 3, [4]]
lst2 = [4, 5, 6]
l_sum = lst1 + lst2
l_sum[3].append(9)
print(lst1, lst2, l_sum)
l_multi = lst1 * 2
l_multi[3].append(8)
print(lst1, lst2, l_multi)

输出的结果为：
[1, 2, 3, [4, 9]] [4, 5, 6] [1, 2, 3, [4, 9], 4, 5, 6]
[1, 2, 3, [4, 9, 8]] [4, 5, 6] [1, 2, 3, [4, 9, 8], 1, 2, 3, [4, 9, 8]]
```

#### 元组

元组需要补充的内容不多，只需要掌握下面这三种小括号的含义即可：

```python
tu = (10) # int,括号中只有一个元素且没有任何逗号，那就表示该元素本身。此时，括号可以看成一个运算符。
tu = (10,) # tuple,括号中虽然只有一个元素，但是元素后面有一个逗号，表示这是一个元组
tu = () # tuple,这是空元组的表示方法，括号中什么都没有。
```

#### 字典

`.fromkeys()`方法用来批量创建键值对，此时需要两个参数，参数1是一个可迭代对象，将会迭代添加到字典中成为键，参数2是这些键共用的值：

```python
dic = {"key": 1, "key1": 2}
dic1 = dic.fromkeys("abc", 12)
print(dic,dic1)

结果：
{'key': 1, 'key1': 2} {'a': 12, 'b': 12, 'c': 12}
```

这里需要注意的是，`.fromkeys()`方法并不是修改字典的方法，而是会创建一个新字典并返回。

另外一个需要注意的是，如果参数2是可变数据，所有的值会共用这个数据：

```
l = []
dic = dict().fromkeys('abc', l)
l.append(2)
print(l, dic)

输出的结果为：[2] {'a': [2], 'b': [2], 'c': [2]}
```

#### 表示False的方法：

所有数据类型，只要是空的，就是False，否则就是True。

```
False
print(bool(0))
print(bool())
print(bool(None))
print(bool(""))
print(bool([]))
print(bool(()))
print(bool({}))
print(bool(set()))
```

#### 类型转换

```
tuple(list)
list(tuple)

set(list)
list(set)

set(tuple)
tuple(set)

int(str)  # 字符串中必须全部都是阿拉伯数字
str(int)

s1 = "".join('列表','元组')    # 将列表转换成字符串   ****
s.split(":")              # 将字符串转化成列表   ****

str(dict)
str(list)
str(tuple)
str(int)
str(set)
str(bool)
```

#### 基础数据类型总结

| 数据类型 | 有序无序 | 是否可变 | 可否迭代 | 查看方式     |
| -------- | -------- | -------- | -------- | ------------ |
| int      | 有序     | 不可变   | 不可迭代 | 直接查看     |
| bool     | -        | 不可变   | 不可迭代 | 直接查看     |
| str      | 有序     | 不可变   | 可迭代   | 通过索引查看 |
| tuple    | 有序     | 不可变   | 可迭代   | 通过索引查看 |
| list     | 有序     | 可变     | 可迭代   | 通过索引查看 |
| dict     | 无序     | 可变     | 可迭代   | 通过键查看   |
| set      | 无序     | 可变     | 可迭代   | for循环查看  |

#### 循环删除的坑

有这样一个列表：`lst = [11, 22, 33, 44, 55]`现在我们想要把列表中的每一个元素都删除掉，但是不能用`.clear()`方法。我们很理所当然地会想到for循环逐个删除：

```python
lst = [11, 22, 33, 44, 55]
for i in lst:
    lst.remove(i)
print(lst)

结果：
[22, 44]
```

居然没有删除干净。

这是python中循环的自主计数和列表的自动补位共同影响下的结果。在循环第一圈时，循环操作从索引值为0的位置找元素，返回了11，被成功删除。当列表删除了11之后，后面的元素会自动补位上来，此时，22的索引变成了0，33的索引变成了1。随后，进入第二圈循环，循环操作会自主把计数加一，开始找索引值为1的元素，也就是33，被成功删除，而22，被忽略掉了。如此一来，所有偶数索引的元素都被删除，奇数索引的元素被保留下来。

为了应对这种循环删除的坑，我们可以采取两种方式[^1](https://gitee.com/oldboy-python-full-stack-26/19083026021/blob/master/week03/day07/应对方法不止这两种，可以任意开发)。

方法一，使用range获取字符串长度，控制循环次数，保证能够完全删除：

```python
lst = [11, 22, 33, 44, 55]
for i in range(len(lst)):
    lst.pop()
print(lst)
```

方法二，通过复制一个列表，通过循环复制的列表，控制循环次数：

```python
lst = [11, 22, 33, 44, 55]
for i in lst.copy():
    lst.remove(i)
print(lst)
```

除了列表之外，字典和集合也深受循环删除的坑的困惑，与列表不能删除干净不同的是，字典和集合在迭代过程中是不可以修改字典的长度，一旦有修改，就会报错。也就是说，一旦在迭代过程中删除键值对，程序直接报错：

```python
dic = {"key": 1, "key1": 2}
for i in dic:
    dic.pop(i)
print(dic)

RuntimeError: dictionary changed size during iteration
```

同样地，我们也可以通过复制一份字典，然后通过迭代新的字典来删除原来字典中的键值对：

```python
dic = {"key": 1, "key2": 2}
for i in dic.copy():
    dic.pop(i)
print(dic)
```

### 二次编码

#### 编码回顾

```
ascii : 英文,数字,符号
    英文: 1个字节,8位

gbk   : 英文,数字,符号,中文
    英文: 1个字节,8位
    中文: 2个字节,16位

unicode : 英文,数字,符号,中文
    英文: 4个字节,32位
    中文: 4个字节,32位

utf-8 : 英文,数字,符号,中文
    英文: 1个字节,8位
    欧洲: 2个字节,16位
    亚洲: 3个字节,24位
```

在python 3的内存中使用的是Unicode编码，而硬盘中存储时使用的是选择的编码方式[^2](https://gitee.com/oldboy-python-full-stack-26/19083026021/blob/master/week03/day07/对于中文来说，主要是gbk和utf-8)。这样一来，就需要进行Unicode和其他编码方式的转变，也就涉及到编码和解码的问题。

编码是将字符转化为二进制的形式，使用的是`.encode()`方法：

```python
s = "你好"
s1 = s.encode("utf-8") # 编码
print(s1)
结果：
b'\xe4\xbd\xa0\xe5\xa5\xbd'
```

解码是将二进制形式的数据转换成字符，使用的是`.decode()`方法：

```python
s = b'\xe4\xbd\xa0\xe5\xa5\xbd'
s2 = s.decode()
print(s2)

结果：
你好
```



需要注意的是，用什么方式进行编码，就需要用什么方式进行解码。解码方式使用错误，轻则乱码，重则报错。

编码的用处主要在两个方面：

1. 存储，涉及到文件操作
2. 传输，涉及到网络编程









